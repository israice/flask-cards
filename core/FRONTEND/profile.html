<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Profile</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Bootstrap Icons for coin icon -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    /* Full-screen centered layout */
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 500px;
      /* background: linear-gradient(135deg, #f0f4f8, #ffffff); */
      background: #f0f4f8;
      font-family: 'Segoe UI', sans-serif;
    }

    .navbar {
      background-color: #ffffff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .vertical-cards-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1 1 auto;
      overflow-y: auto;
      padding: 1rem;
    }

    /* Shared card styles */
    .vertical-cards {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      width: 100%;
      max-width: 800px;
      /* Increased width to accommodate side coins */
    }

    /* The wrapper for the whole item (Card + Money panel) */
    .card-wrapper {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      gap: 1rem;
      width: 100%;
      height: 380px;
      /* Fixed height for consistency */
      background: transparent;
    }

    /* 
       LEFT SIDE: The Flippable Card 
       Contains Image and Overlaid Stats
    */
    .card-flip-container {
      position: relative;
      flex: 0 0 280px;
      /* Fixed width for the image part */
      height: 100%;
      perspective: 1000px;
      cursor: pointer;
    }

    .card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      text-align: center;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      border-radius: 10px;
    }

    .card-flip-container.flipped .card-inner {
      transform: rotateY(180deg);
    }

    .card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      border-radius: 10px;
      overflow: hidden;
    }

    /* FRONT FACE: Image + Overlay */
    .card-front {
      background-color: #000;
      display: flex;
      flex-direction: column;
    }

    .card-img-full {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.85;
      /* Slight dim for text readability */
    }

    .card-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      /* Text at bottom */
      align-items: flex-start;
      color: white;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
      pointer-events: none;
      /* Let clicks pass through to container */
      background: linear-gradient(to bottom, transparent 40%, rgba(0, 0, 0, 0.7) 100%);
    }

    .overlay-stat {
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
      text-align: left;
    }

    .overlay-stat strong {
      color: #ffd700;
      /* Goldish for labels */
      margin-right: 0.3rem;
    }

    /* BACK FACE: Details */
    .card-back {
      background-color: #1a1a1a;
      color: white;
      transform: rotateY(180deg);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1rem;
    }

    /* 
       RIGHT SIDE: The Static Coins Panel 
    */
    .card-coins-panel {
      flex: 1 1 auto;
      height: 100%;
      background: #ffffff;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    /* Reuse existing coin table styles */
    .stat-coins table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .stat-coins td {
      padding: 0.4rem;
      border-bottom: 1px solid #eee;
    }

    .stat-coins td:first-child {
      font-weight: bold;
      color: #555;
    }
  </style>
</head>

<body>
  <nav class="navbar navbar-light">
    <div class="container-fluid d-flex justify-content-between align-items-center">
      <a class="navbar-brand" href="#">MyApp</a>
      <div class="d-flex align-items-center">
        <span class="me-3">{{ user.username }}</span>
        {% if is_admin %}
        <a class="btn btn-primary me-2" href="{{ url_for('table') }}">Table</a>
        {% endif %}
        <a class="btn btn-outline-danger" href="{{ url_for('logout') }}">Log Out</a>
      </div>
    </div>
  </nav>

  <div class="vertical-cards-container">
    <h3>Your Cards</h3>
    <div id="cards-container" class="vertical-cards"></div>
  </div>


  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log('[DEBUG] DOMContentLoaded');
      const container = document.getElementById('cards-container');

      const templates = {};

      function loadTemplates() {
        console.log('[DEBUG] loadTemplates searching for fragments...');
        const mapping = {
          'STATUS_1': '/card_1.html',
          'STATUS_2': '/card_2.html',
          'STATUS_3': '/card_3.html'
        };
        return Promise.all(
          Object.entries(mapping).map(([status, url]) =>
            fetch(url)
              .then(res => {
                if (!res.ok) throw new Error(`Failed to load ${url}`);
                return res.text();
              })
              .then(html => {
                const div = document.createElement('div');
                div.innerHTML = html;
                templates[status] = div.querySelector('template').content;
              })
          )
        );
      }

      // Helper to update or create a card element
      function updateCardElement(el, card, isNew) {
        // console.log(`[DEBUG] updateCardElement ID=${card.CARD_ID} isNew=${isNew}`);
        // 1. Text Fields
        const safeText = (sel, val) => {
          el.querySelectorAll(sel).forEach(e => {
            const newVal = val || '';
            if (e.textContent !== newVal) {
              // console.log(`[DEBUG] Updating text ${sel}: ${newVal}`);
              e.textContent = newVal;
            }
          });
        };
        safeText('.card-chain', card.CARD_CHAIN);
        safeText('.card-name', card.CARD_NAME);
        safeText('.card-theme', card.CARD_THEME);
        safeText('.card-type', card.CARD_TYPE);
        safeText('.card-id', card.CARD_ID);
        safeText('.pack-id', card.PACK_ID);
        safeText('.card-date', card.CARD_DATE);

        // 2. Image
        const img = el.querySelector('.card-img-top');
        // Check raw attribute to avoid absolute/relative URL mismatch causing reloads
        if (img && img.getAttribute('src') !== card.url) {
          console.log(`[DEBUG] Updating image for ${card.CARD_ID}: ${img.getAttribute('src')} -> ${card.url}`);
          img.src = card.url;
        }

        // 3. Coins Table
        const coinsContainer = el.querySelector('.stat-coins');
        if (coinsContainer) {
          const coinsArr = (card.CARD_COINS || '').split(',').map(s => s.trim()).filter(s => s);
          const amountArr = (card.USD_AMMOUNT || '').split(',').map(s => s.trim());
          const isStatus1 = (card.status === 'STATUS_1');
          const isStatus3 = (card.status === 'STATUS_3');

          // Add click listener for activation if not already valid/active
          // Logic: If NOT Status 3, clicking prompts to/activate.
          // Note: User said click "where USD part should display". That IS the coinsContainer.
          // We need to ensure we don't add multiple listeners.
          // Better to set onclick directly or handle via specific class/attribute state.

          if (!coinsContainer.hasAttribute('data-click-setup')) {
            coinsContainer.setAttribute('data-click-setup', 'true');
            coinsContainer.style.cursor = 'pointer';
            coinsContainer.addEventListener('click', (e) => {
              // Determine current status from the DOM or data attribute
              // The parent scope 'card' variable here is from the closure of updateCardElement.
              // However, updateCardElement is called repeatedly.
              // It is safer to read the card-id from the element and fetch current state or trust the closure?
              // The closure 'card' IS the latest data provided to updateCardElement.

              // If already active, maybe do nothing?
              if (el.dataset.status === 'STATUS_3') return;

              if (confirm("ACTIVATE CARD?\n\nPress OK to Reveal USD.")) {
                fetch('/activate_card', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ card_id: card.CARD_ID })
                })
                  .then(r => r.json())
                  .then(data => {
                    if (data.status === 'success') {
                      // Force a reload or wait for next poll
                      // We can optimistically update data-status
                      el.dataset.status = 'STATUS_3';
                      // The next poll (5s) will refresh the UI fully.
                      // Or we could trigger loadCards() immediately.
                      loadCards();
                    } else {
                      alert("Activation failed: " + data.message);
                    }
                  })
                  .catch(err => alert("Error: " + err));
              }
            });
          }

          // Store status on element for the click handler to check latest
          el.dataset.status = card.status;


          // Serialize data to check for changes
          // Include Status3 in hash
          const newDataString = JSON.stringify({ coinsArr, amountArr, isStatus1, isStatus3 });
          const currentDataString = coinsContainer.getAttribute('data-coins-hash');

          // Only rebuild if data changed
          if (newDataString !== currentDataString) {
            // console.log(`[DEBUG] Updating coins for ${card.CARD_ID}`);
            coinsContainer.setAttribute('data-coins-hash', newDataString);
            coinsContainer.innerHTML = '';

            // Visual state for unactivated cards?
            // If not status 3, maybe we hide the amounts?
            // The existing logic: 
            // isStatus1 -> 2 cols (Label | Icon)
            // !isStatus1 -> 4 cols (Label | Icon | Name | Amount)
            //
            // New Requirement: "Always display with USD" ONLY after STATUS_3.
            // So if STATUS_2 (Owned but not active) -> Should it show amounts?
            // User said: "if CONTINUE ... Status_3 ... from this moment always display with USD".
            // Implies before STATUS_3, it does NOT show USD.

            // So:
            // STATUS_1 (Created): No USD. (2 cols?)
            // STATUS_2 (Owned): No USD. (2 cols? or 4 cols with hidden amount?) 
            // STATUS_3 (Active): With USD. (4 cols)

            // Re-evaluating existing logic:
            // if (isStatus1) -> 2 cols.
            // else -> 4 cols.

            // If we want to hide USD for STATUS_2, we should treat it like STATUS_1 visually? 
            // OR use a new visual state with "ACTIVATION REQUIRED"?
            // Assuming "Show USD" means the full 4-col table.

            const showFullTable = isStatus3;
            // If STATUS_2, we might want to show Name but not Amount? Or just same as STATUS_1?
            // User phrasing: "STATUS_3 ... already displays amount ... " implies STATUS_2 does not.
            // Let's assume STATUS_1 and STATUS_2 look "compact" (2 cols) or "hidden values".
            // Let's stick to: Show Full Table (4 cols) ONLY if STATUS_3.

            const table = document.createElement('table');
            const colgroup = document.createElement('colgroup');

            if (!showFullTable) {
              // Compact Mode (Hidden USD)
              // Two cols: Label | Icon
              const c1 = document.createElement('col'); c1.style.width = '3rem';
              const c2 = document.createElement('col'); c2.style.width = '20px';
              colgroup.append(c1, c2);
            } else {
              // Full Mode (Visible USD)
              // Four cols: Label | Icon | Name | Amount
              ['3rem', '20px', 'auto', 'auto'].forEach(w => {
                const c = document.createElement('col');
                c.style.width = w;
                colgroup.appendChild(c);
              });
            }
            table.appendChild(colgroup);

            // Pre-built GIF HTML
            // Maybe different GIF for Status 3?
            // Existing: Status 1 -> Specific GIF, Else -> Other GIF.
            const gifUrl = isStatus1 ? `https://cdn.pixabay.com/animation/2024/08/15/20/58/20-58-49-129_512.gif` : `https://cdn.pixabay.com/animation/2022/12/21/03/30/03-30-53-418_512.gif`;

            const gifHtml =
              '<div style="width:18px;height:18px;overflow:hidden;display:inline-flex;align-items:center;justify-content:center;">' +
              `<img src="${gifUrl}" style="width:28px;height:28px;transform:scale(1.8);object-fit:contain;pointer-events:none;">` +
              '</div>';

            coinsArr.forEach((coin, idx) => {
              const tr = document.createElement('tr');
              // Label (rowspan)
              if (idx === 0) {
                const tdLabel = document.createElement('td');
                tdLabel.rowSpan = coinsArr.length || 1;
                tdLabel.textContent = 'CARD_COINS';
                tdLabel.style.textAlign = 'center';
                tdLabel.style.verticalAlign = 'middle';
                tr.appendChild(tdLabel);
              }
              // GIF
              const tdIcon = document.createElement('td');
              tdIcon.style.textAlign = 'center';
              tdIcon.style.verticalAlign = 'middle';
              tdIcon.innerHTML = gifHtml;
              tr.appendChild(tdIcon);

              if (showFullTable) {
                // Name
                const tdName = document.createElement('td');
                tdName.textContent = coin;
                tdName.style.textAlign = 'left';
                tdName.style.verticalAlign = 'middle';
                tr.appendChild(tdName);
                // Amount
                const tdAmt = document.createElement('td');
                tdAmt.textContent = amountArr[idx] || '';
                tdAmt.style.textAlign = 'left';
                tdAmt.style.verticalAlign = 'middle';
                tr.appendChild(tdAmt);
              }
              table.appendChild(tr);
            });
            coinsContainer.appendChild(table);
          }
        }
      }

      function renderCards(cards) {
        console.log(`[DEBUG] renderCards called with ${cards.length} cards.`);
        // Collect current IDs for cleanup
        const incomingIds = new Set();

        cards.forEach(card => {
          const cardId = card.CARD_ID;
          incomingIds.add(cardId);

          // Try to find existing card
          let cardEl = container.querySelector(`.card-wrapper[data-card-id="${cardId}"]`);
          let isNew = false;

          if (!cardEl) {
            isNew = true;
            console.log(`[DEBUG] Creating new DOM element for card ${cardId}`);
            const tmpl = templates[card.status] || templates['STATUS_1'];
            const clone = tmpl.cloneNode(true);
            // The template content might be a DocumentFragment, we need the Element
            // Our templates have a single root div.card-wrapper
            cardEl = clone.firstElementChild;
            if (!cardEl) return; // Should not happen

            cardEl.setAttribute('data-card-id', cardId);

            // One-time setup
            const flipContainer = cardEl.querySelector('.card-flip-container');
            if (flipContainer) {
              flipContainer.onclick = () => {
                console.log(`[DEBUG] Card ${cardId} clicked! Toggling flip.`);
                flipContainer.classList.toggle('flipped');
              };
            }
          }

          // Update content (re-renders table, updates text)
          updateCardElement(cardEl, card, isNew);

          // Ensure order: appendChild moves existing nodes to the end
          container.appendChild(cardEl);
        });

        // Cleanup removed cards
        Array.from(container.children).forEach(child => {
          if (!incomingIds.has(child.dataset.cardId)) {
            console.log(`[DEBUG] Removing stale card ID: ${child.dataset.cardId}`);
            child.remove();
          }
        });
      }

      function initialize() {
        console.log('[DEBUG] initialize() started');
        const saved = localStorage.getItem('cards');
        if (saved) {
          try { renderCards(JSON.parse(saved)); }
          catch { localStorage.removeItem('cards'); }
        }
        async function loadCards() {
          try {
            // console.log('[DEBUG] Fetching /api/cards ...');
            const res = await fetch('/api/cards');
            if (!res.ok) throw new Error('Network response was not ok');
            const cards = await res.json();
            // console.log(`[DEBUG] Fetched ${cards.length} cards.`);
            renderCards(cards);
            localStorage.setItem('cards', JSON.stringify(cards));
          } catch (err) {
            console.error('Failed to load cards:', err);
          }
        }
        window.loadCards = loadCards;
        loadCards();
        setInterval(loadCards, 5000);
      }

      loadTemplates()
        .then(initialize)
        .catch(err => console.error(err));
    });
  </script>

</body>

</html>